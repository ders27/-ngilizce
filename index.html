<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Atıcı Konum Tahmini — Basit 3D Rekonstrüksiyon</title>
<style>
  body{font-family:Inter,Arial;margin:16px;background:#f5f7fb;color:#111}
  .card{background:#fff;border-radius:10px;padding:16px;box-shadow:0 6px 20px rgba(30,40,60,.08);max-width:920px;margin:0 auto}
  label{display:block;margin-top:10px;font-weight:600}
  input,select{width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;margin-top:6px}
  button{margin-top:12px;padding:10px 16px;border:0;border-radius:8px;background:#2563eb;color:#fff;font-weight:700;cursor:pointer}
  .res{margin-top:14px;padding:12px;background:#eef6ff;border-left:4px solid #2b6df6;border-radius:6px}
  .row{display:flex;gap:12px}
  .col{flex:1}
  svg{width:100%;height:260px;background:#fff;border-radius:8px;border:1px solid #e5e7eb}
  .muted{color:#555;font-size:0.95rem}
</style>
</head>
<body>
  <div class="card">
    <h2>Atıcı Konum Tahmini (3D)</h2>
    <p class="muted">Olay yerinde ölçtüğünüz verileri girin — form girdi alanları ve kısa açıklamalar altında.</p>

    <div class="row">
      <div class="col">
        <label>Kısa Eksen (cm)</label>
        <input id="kisa" type="number" step="0.01" value="0.4">
      </div>
      <div class="col">
        <label>Uzun Eksen (cm)</label>
        <input id="uzun" type="number" step="0.01" value="1.2">
      </div>
    </div>

    <label>Elipsin duvarda yaptığı yatay açı — uzun eksenin yatay referansa (yatay boyunca sağa) açısı (°)</label>
    <input id="elips_yon" type="number" step="0.1" value="10" placeholder="0 = yatay, 90 = dikey yukarı">

    <div class="row">
      <div class="col">
        <label>İsabet yüksekliği (cm) — duvardaki deliğin yerden yüksekliği</label>
        <input id="isabet" type="number" step="1" value="250">
      </div>
      <div class="col">
        <label>Atıcının silah tutma yüksekliği (cm) (tahmini)</label>
        <input id="atis_h" type="number" step="1" value="160">
      </div>
    </div>

    <label>Duvardaki sol kenardan deliğe yatay mesafe (cm) — duvar üzerindeki y koordinatı için</label>
    <input id="duvar_sol" type="number" step="0.1" value="120">

    <label>Duvarın dünya yönü (duvarın düzlüğünün yatay yönü) — rotasyon (°) (opsiyonel)</label>
    <input id="duvar_acisi" type="number" step="0.1" value="0" placeholder="0 = duvar x=0, y artı yönü sağa">

    <button onclick="hesaplaAtici()">HESAPLA</button>

    <div id="sonuc" class="res">
      <p>Henüz hesap yok. Değerleri girip "HESAPLA" butonuna basın.</p>
    </div>

    <h3 style="margin-top:18px">Görsel (üstten plan ve yan görünüş)</h3>
    <svg id="viz" viewBox="0 0 800 400" preserveAspectRatio="xMidYMid meet">
      <rect x="0" y="0" width="800" height="400" fill="#f8fafc"></rect>
      <g id="plan"></g>
    </svg>
  </div>

<script>
// Yardımcı fonksiyonlar
function deg2rad(d){return d*Math.PI/180}
function rad2deg(r){return r*180/Math.PI}

// Ana hesap fonksiyonu
function hesaplaAtici(){
  // Girdi al
  const kisa_cm = parseFloat(document.getElementById('kisa').value);
  const uzun_cm = parseFloat(document.getElementById('uzun').value);
  const elips_yon_deg = parseFloat(document.getElementById('elips_yon').value); // derecede, 0 = yatay sağa
  const isabet_cm = parseFloat(document.getElementById('isabet').value);
  const atis_h_cm = parseFloat(document.getElementById('atis_h').value);
  const duvar_sol_cm = parseFloat(document.getElementById('duvar_sol').value);
  const duvar_acisi_deg = parseFloat(document.getElementById('duvar_acisi').value) || 0;

  // Basit validasyon
  if (isNaN(kisa_cm) || isNaN(uzun_cm) || isNaN(isabet_cm) || isNaN(atis_h_cm)) {
    document.getElementById('sonuc').innerHTML = '<strong>Hata:</strong> Lütfen tüm zorunlu alanları doğru doldurun.';
    return;
  }
  if (kisa_cm <= 0 || uzun_cm <= 0 || kisa_cm > uzun_cm) {
    document.getElementById('sonuc').innerHTML = '<strong>Hata:</strong> Kısa eksen pozitif olmalı ve uzun eksenden küçük olmalı.';
    return;
  }

  // Birim dönüşümleri => metre
  const b = kisa_cm / 100.0;
  const a = uzun_cm / 100.0;
  const Pz = isabet_cm / 100.0; // etki z
  const Py = duvar_sol_cm / 100.0; // etki y (wall-local)
  const shooter_h = atis_h_cm / 100.0;
  const wallRot = deg2rad(duvar_acisi_deg);

  // 1) çarpış açısı (theta) : cosθ = b/a
  const ratio = Math.min(Math.max(b/a, 0), 1);
  const theta = Math.acos(ratio); // rad
  const theta_deg = rad2deg(theta);

  // 2) wall-plane yön açısı (alpha) — elips_yon: 0° = yatay (y pozitif), pozitif açı yukarı doğru
  const alpha = deg2rad(elips_yon_deg);

  // 3) birim yön vektörü (duvar-normal ekseninde x; wall-plane: y (sağa), z (yukarı))
  // Duvar normal'i +x olsun; mermi atıcı tarafından geliyorsa atıcı yönü wall içi pozitif x yönünde
  // Biz merminin geldiği yönden atıcıya doğru yön oluşturuyoruz:
  const dx = -Math.cos(theta); // negatif x (duvardan içeri doğru gelen vektör)
  const planeProj = Math.sin(theta); // büyüklük duvar düzlemindeki projeksiyon
  const dy = planeProj * Math.cos(alpha); // wall-local y
  const dz = planeProj * Math.sin(alpha); // wall-local z (yukarı pozitif)

  // P noktası (impact) wall-local coordinate (x=0)
  let Px = 0.0, Py_local = Py, Pz_local = Pz;

  // d vector (unit) pointing FROM impact TOWARD shooter:
  const d_local = {x: dx, y: dy, z: dz};

  // Eğer dikey bileşen çok küçükse, yükseklik kesişimi hesaplanamaz veya paralel
  if (Math.abs(d_local.z) < 1e-8) {
    document.getElementById('sonuc').innerHTML = '<strong>Uyarı:</strong> Merminin duvara paralel veya çok yatay geldiği tespit edildi (d_z ≈ 0). Atıcının yüksekliğe göre konumu bu modelle bulunamaz.';
    drawVisualization(Px,Py_local,Pz_local,d_local,null,null);
    return;
  }

  // t parametresi: Pz + t * d_z = shooter_h  => t = (shooter_h - Pz) / d_z
  const t = (shooter_h - Pz_local) / d_local.z;

  // Biz t > 0 bekleriz (çünkü d vector shooter yönüne doğru); eğer t negatifse, atıcı z-uyumlu değil.
  if (t <= 0) {
    // t negatif ise d vector yönüne göre atıcı arkamızda; bu durumda yine S = P + t*d hesaplanır ama mantık yorumlanmalı.
    // Yine hesaplayıp gösterelim ama uyarı verelim.
  }

  // S point in wall-local coordinates:
  const Sx_local = Px + t * d_local.x;
  const Sy_local = Py_local + t * d_local.y;
  const Sz_local = Pz_local + t * d_local.z;

  // Rotate wall-local (x,y) by wallRot about z to get global coordinates:
  function rotateXY(x,y,ang){
    const c=Math.cos(ang), s=Math.sin(ang);
    return {X: x*c - y*s, Y: x*s + y*c};
  }
  const Pglob = rotateXY(Px, Py_local, wallRot);
  const Sglob = rotateXY(Sx_local, Sy_local, wallRot);
  // Z stays same
  const Pglobal = {x:Pglob.X, y:Pglob.Y, z:Pz_local};
  const Sglobal = {x:Sglob.X, y:Sglob.Y, z:Sz_local};

  // Mesafeler:
  const dxs = Sglobal.x - Pglobal.x;
  const dys = Sglobal.y - Pglobal.y;
  const dzs = Sglobal.z - Pglobal.z;
  const eucl = Math.sqrt(dxs*dxs + dys*dys + dzs*dzs);
  const horizontalDistance = Math.sqrt(dxs*dxs + dys*dys);

  // Duvara normal yönde uzaklık (Sx_local negatif ise atıcı duvarın önünde)
  const dist_from_wall = Math.abs(Sx_local);

  // Sonuç metni
  let info = `<h3>Sonuç (Tahmini)</h3>`;
  info += `<p><strong>Çarpış açısı (theta):</strong> ${theta_deg.toFixed(2)}°</p>`;
  info += `<p><strong>Elips yönü (duvar plaindeki alpha):</strong> ${elips_yon_deg.toFixed(2)}°</p>`;
  info += `<p><strong>Atıcının tahmini koordinatları (global):</strong><br>
           X = ${Sglobal.x.toFixed(3)} m, Y = ${Sglobal.y.toFixed(3)} m, Z = ${Sglobal.z.toFixed(3)} m</p>`;
  info += `<p><strong>Atıcı ile isabet noktası arası mesafe:</strong> ${eucl.toFixed(3)} m (yatay: ${horizontalDistance.toFixed(3)} m)</p>`;
  info += `<p><strong>Atıcının duvardan uzaklığı (duvar-normal yönünde):</strong> ${dist_from_wall.toFixed(3)} m</p>`;
  if (t <= 0) {
    info += `<p style="color:#c00"><strong>Uyarı:</strong> Hesaplanan parametrik t ≤ 0 çıktı (${t.toFixed(3)}). Bu, seçilen yön vektörüne göre atıcının impact noktasının ters yönünde kalabileceğini gösterir. Ölçüleri (elips yönü / yükseklik) tekrar kontrol edin.</p>`;
  }
  info += `<hr><p class="muted">Not: Bu model geometri temelli (doğrusal) bir tahmindir. Mermi deformasyonu, yaw, rüzgâr, yorgun mermi, yüzey eğriliği veya fotoğraf/ölçüm hataları sonucu yanıltabilir.</p>`;

  document.getElementById('sonuc').innerHTML = info;

  // çizim
  drawVisualization(Px,Py_local,Pz_local,d_local,Sglobal,Pglobal);
}

// Basit görselleştirme (üstten plan + yan)
function drawVisualization(Px,Py,Pz,d_local,Sglobal,Pglobal){
  const svg = document.getElementById('viz');
  const g = document.getElementById('plan');
  while(g.firstChild) g.removeChild(g.firstChild);

  // Koordinatları normalize edip 2D plan ve yan görüntü çizimleri yapacağız.
  // Plan view: x (duvardan uzaklık) -> right, y -> down
  // Yan view: horizontal distance (duvardan uzaklık) -> right, z -> up

  // Build simple shapes scaled to fit
  // Collect points in local wall coords for drawing if Sglobal provided, rotate back to wall-local for easy plan.
  // For simplicity we'll convert Sglobal back to wall-local by inverse rotation assuming wall rot 0 (we don't store wallRot globally)
  // Instead, draw only wall-local info available: P at (x=0, y=Py, z=Pz) and S at P + t*d_local if Sglobal present compute S_local via logic
  // For brevity here do a minimal drawing: show wall vertical line and shooter point by using Sglobal coords scaled.

  // create simple text about plan/side
  const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
  txt.setAttribute("x",14); txt.setAttribute("y",20);
  txt.setAttribute("font-size",12); txt.setAttribute("fill","#333");
  txt.textContent = "Basit görsel (üstten plan ve yan görünüş):";
  g.appendChild(txt);

  // If we have Sglobal and Pglobal - draw approximate topdown (Y vs X)
  if (Sglobal && Pglobal){
    // find bounding box
    const pts = [
      {x:Pglobal.x,y:Pglobal.y},
      {x:Sglobal.x,y:Sglobal.y}
    ];
    // margins; create scaling
    const minX = Math.min(...pts.map(p=>p.x));
    const maxX = Math.max(...pts.map(p=>p.x));
    const minY = Math.min(...pts.map(p=>p.y));
    const maxY = Math.max(...pts.map(p=>p.y));
    const pad = 0.5; // meters padding
    const W = 760, H = 300;
    const scale = Math.min((W-40)/(Math.max(0.001,maxX-minX)+pad*2),(H-40)/(Math.max(0.001,maxY-minY)+pad*2));
    const offsetX = 20 - (minX - pad)*scale;
    const offsetY = 30 - (minY - pad)*scale;

    // line from shooter to impact (top-down)
    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", offsetX + Pglobal.x*scale);
    line.setAttribute("y1", offsetY + Pglobal.y*scale);
    line.setAttribute("x2", offsetX + Sglobal.x*scale);
    line.setAttribute("y2", offsetY + Sglobal.y*scale);
    line.setAttribute("stroke","#1f6feb"); line.setAttribute("stroke-width",2);
    g.appendChild(line);

    // impact point
    const c1 = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c1.setAttribute("cx", offsetX + Pglobal.x*scale);
    c1.setAttribute("cy", offsetY + Pglobal.y*scale);
    c1.setAttribute("r",5); c1.setAttribute("fill","#ef4444");
    g.appendChild(c1);
    const t1 = document.createElementNS("http://www.w3.org/2000/svg","text");
    t1.setAttribute("x", offsetX + Pglobal.x*scale + 8); t1.setAttribute("y", offsetY + Pglobal.y*scale + 4);
    t1.setAttribute("font-size",11); t1.setAttribute("fill","#333");
    t1.textContent = "İsabet";
    g.appendChild(t1);

    // shooter point
    const c2 = document.createElementNS("http://www.w3.org/2000/svg","rect");
    c2.setAttribute("x", offsetX + Sglobal.x*scale -5);
    c2.setAttribute("y", offsetY + Sglobal.y*scale -5);
    c2.setAttribute("width",10); c2.setAttribute("height",10);
    c2.setAttribute("fill","#059669");
    g.appendChild(c2);
    const t2 = document.createElementNS("http://www.w3.org/2000/svg","text");
    t2.setAttribute("x", offsetX + Sglobal.x*scale + 8); t2.setAttribute("y", offsetY + Sglobal.y*scale + 4);
    t2.setAttribute("font-size",11); t2.setAttribute("fill","#333");
    t2.textContent = "Tahmini Atıcı (üstten)";
    g.appendChild(t2);

    // legend
    const leg = document.createElementNS("http://www.w3.org/2000/svg","text");
    leg.setAttribute("x",14); leg.setAttribute("y",300);
    leg.setAttribute("font-size",11); leg.setAttribute("fill","#555");
    leg.textContent = "Not: Bu çizim üstten plan (X,Y). Duvara göre oryantasyon ve gerçek dünya referansları için duvar açısını kullanın.";
    g.appendChild(leg);
  } else {
    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x",14); t.setAttribute("y",60);
    t.setAttribute("font-size",12); t.setAttribute("fill","#666");
    t.textContent = "Yeterli veri yok; sonuç bölümündeki uyarıyı kontrol edin.";
    g.appendChild(t);
  }
}
</script>
</body>
</html>
